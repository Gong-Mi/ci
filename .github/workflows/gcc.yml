name: 构建 GCC Magisk 模块

on:
  push:
    branches: [ main ] # 或者你的开发分支
  workflow_dispatch: # 允许手动触发

jobs:
  build:
    runs-on: ubuntu-latest # 必须使用 Linux 运行环境
    env: # 定义 Job 级别的环境变量,供所有步骤共享
      GCC_VERSION: "12.2.0"
      BINUTILS_VERSION: "2.39"
      GMP_VERSION: "6.2.1"
      MPFR_VERSION: "4.1.0"
      MPC_VERSION: "1.2.1"
      NDK_VERSION: "android-ndk-r27c" # NDK 版本 - 已更新
      TARGET_ARCH: "aarch64"          # 目标架构
      API_LEVEL: "30"                 # Android API Level (可以根据需要调高)

    steps:
    - name: 检出代码 (如果你的仓库包含辅助脚本/配置)
      uses: actions/checkout@v3

    - name: 安装基础依赖
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        sudo apt-get update
        sudo apt-get install -y build-essential wget unzip bc tar xz-utils texinfo # texinfo is often needed for make install
        echo "基础依赖安装完成。"

    - name: 设置 Android NDK
      id: setup-ndk
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        echo "正在下载 NDK ${NDK_VERSION}..." # 使用 env 中定义的 NDK_VERSION
        wget -q https://dl.google.com/android/repository/${NDK_VERSION}-linux.zip
        unzip -q ${NDK_VERSION}-linux.zip
        # 将 NDK 路径添加到后续步骤的 GitHub Actions 环境变量
        echo "ANDROID_NDK_HOME=${GITHUB_WORKSPACE}/${NDK_VERSION}" >> $GITHUB_ENV
        echo "NDK 路径: ${GITHUB_WORKSPACE}/${NDK_VERSION}"

    - name: 定义构建特定变量
      id: build-vars
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        # TARGET_ARCH 和 API_LEVEL 从 job.env 获取
        TARGET_TRIPLE="${TARGET_ARCH}-linux-android"
        # NDK Clang 通常需要 API Level 后缀
        TOOLCHAIN_TARGET="${TARGET_TRIPLE}${API_LEVEL}"
        # 临时安装目录的前缀
        INSTALL_PREFIX="${GITHUB_WORKSPACE}/install_dir"
        # Magisk 模块目录
        MODULE_DIR="${GITHUB_WORKSPACE}/gcc_magisk_module"
        # 根据架构确定库目录名
        if [ "${TARGET_ARCH}" == "aarch64" ] || [ "${TARGET_ARCH}" == "x86_64" ]; then
          LIB_DIR_NAME="lib64"
        else
          LIB_DIR_NAME="lib"
        fi

        # 将这些变量写入 GitHub Actions 环境变量供后续步骤使用
        echo "TARGET_TRIPLE=${TARGET_TRIPLE}" >> $GITHUB_ENV
        echo "TOOLCHAIN_TARGET=${TOOLCHAIN_TARGET}" >> $GITHUB_ENV
        echo "INSTALL_PREFIX=${INSTALL_PREFIX}" >> $GITHUB_ENV
        echo "MODULE_DIR=${MODULE_DIR}" >> $GITHUB_ENV
        echo "LIB_DIR_NAME=${LIB_DIR_NAME}" >> $GITHUB_ENV # 将库目录名也设为环境变量
        # 将 NDK 工具链添加到全局 PATH 环境变量 (主要影响后续步骤)
        # Prepend NDK path to ensure its tools are found first
        echo "PATH=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin:${PATH}" >> $GITHUB_ENV

        # 创建所需目录
        mkdir -p $INSTALL_PREFIX
        mkdir -p $MODULE_DIR
        echo "构建变量设置完成。"
        echo "INSTALL_PREFIX=${INSTALL_PREFIX}"
        echo "MODULE_DIR=${MODULE_DIR}"
        echo "TARGET_TRIPLE=${TARGET_TRIPLE}"
        echo "TOOLCHAIN_TARGET=${TOOLCHAIN_TARGET}"
        echo "LIB_DIR_NAME=${LIB_DIR_NAME}"
        echo "Initial PATH set in GITHUB_ENV: $PATH"

    - name: 下载源代码 (使用 env 中的版本号)
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        echo "正在下载源码..."
        echo "GCC Version: ${GCC_VERSION}"
        echo "Binutils Version: ${BINUTILS_VERSION}"
        echo "GMP Version: ${GMP_VERSION}"
        echo "MPFR Version: ${MPFR_VERSION}"
        echo "MPC Version: ${MPC_VERSION}"
        wget -q https://ftp.gnu.org/gnu/gcc/gcc-${GCC_VERSION}/gcc-${GCC_VERSION}.tar.gz
        wget -q https://ftp.gnu.org/gnu/binutils/binutils-${BINUTILS_VERSION}.tar.gz
        wget -q https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VERSION}.tar.xz
        wget -q https://ftp.gnu.org/gnu/mpfr/mpfr-${MPFR_VERSION}.tar.xz
        wget -q https://ftp.gnu.org/gnu/mpc/mpc-${MPC_VERSION}.tar.gz
        echo "下载完成,正在解压..."
        tar -xf gcc-${GCC_VERSION}.tar.gz
        tar -xf binutils-${BINUTILS_VERSION}.tar.gz
        tar -xf gmp-${GMP_VERSION}.tar.xz
        tar -xf mpfr-${MPFR_VERSION}.tar.xz
        tar -xf mpc-${MPC_VERSION}.tar.gz
        echo "解压完成。"
        echo "当前工作目录内容 (下载后):"
        ls -l # 列出文件以确认解压成功

    - name: 构建依赖项 (Binutils, GMP, MPFR, MPC)
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        echo "开始构建依赖项..."
        echo "Current PATH for dependency build: $PATH"
        echo "Current work dir: $(pwd)"
        ls -l

        NPROC=$(nproc)
        echo "Using $NPROC parallel jobs for make."

        echo "构建 Binutils (版本: ${BINUTILS_VERSION})..."
        cd binutils-${BINUTILS_VERSION}

        # Binutils is built to RUN on the BUILD machine but TARGET the Android machine
        export CC="${TOOLCHAIN_TARGET}-clang"
        export CXX="${TOOLCHAIN_TARGET}-clang++"
        export AR="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
        export RANLIB="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib"
        export STRIP="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
        export NM="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-nm"

        echo "Checking tools for Binutils:"
        echo "CC is: $CC"
        $CC --version || { echo "CC check failed"; exit 1; }
        echo "AR is: $AR"
        ls -l "$AR"
        "$AR" --version || { echo "AR version check failed"; exit 1; }
        echo "NM is: $NM"
        ls -l "$NM"
        "$NM" --version || { echo "NM version check failed"; exit 1; }


        echo "--- Preparing to configure Binutils ---"
        echo "PWD=$(pwd)"
        ls -l ./configure
        if [ ! -x ./configure ]; then
           echo "错误: configure脚本不存在或不可执行！"
           exit 1
        fi
        echo "Configure command about to run."

        # Execute configure for Binutils: host is build machine, target is android machine
        ./configure --target=${TARGET_TRIPLE} --prefix=${INSTALL_PREFIX} \
                    --host=$(./config.guess) \  # <--- Modified: Host is the build machine
                    --build=$(./config.guess) \
                    --with-sysroot=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot \
                    --disable-nls --disable-werror \
                    --disable-libctf \
                    --disable-gprofng \
                    --disable-static --enable-shared

        echo "运行 Binutils configure 完成。开始 make..."
        make -j${NPROC} || { echo "Binutils make failed"; exit 1; }
        make install || { echo "Binutils make install failed"; exit 1; }
        echo "Binutils 构建和安装完成。"
        cd ..
        echo "Checking Binutils installation in ${INSTALL_PREFIX}/bin:"
        ls -l ${INSTALL_PREFIX}/bin | grep ${TARGET_TRIPLE} || echo "Warning: Binutils tools might not be installed correctly."
        ls -l ${INSTALL_PREFIX}/bin | grep $(./config.guess | sed 's/-pc-linux-gnu//') # Check if native tools were built (shouldn't be with --host=build)


        # --- Build GMP (rest of the script follows) ---
        echo "构建 GMP (版本: ${GMP_VERSION})..."
        cd gmp-${GMP_VERSION}
        # GMP is built to RUN on the ANDROID machine (host) using a CROSS compiler
        export CC="${TOOLCHAIN_TARGET}-clang"
        export CXX="${TOOLCHAIN_TARGET}-clang++"
        export AR="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar" # Still need build-machine tools
        export RANLIB="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib"
        export STRIP="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
         # Make sure the Binutils installed in step 1 are found for 'as', 'ld' etc.
        export PATH="${INSTALL_PREFIX}/bin:${PATH}" # Ensure cross binutils are in path
        echo "Current PATH for GMP build: $PATH"

        ./configure --prefix=${INSTALL_PREFIX} --host=${TARGET_TRIPLE} \ # <--- Host is the Android machine
                     --enable-cxx \
                     --disable-static --enable-shared
        echo "运行 GMP configure 完成。开始 make..."
        make -j${NPROC} || { echo "GMP make failed"; exit 1; }
        make install || { echo "GMP make install failed"; exit 1; }
        echo "GMP 构建和安装完成。"
        cd ..
        echo "Checking GMP installation in ${INSTALL_PREFIX}/include and ${INSTALL_PREFIX}/${LIB_DIR_NAME}:"
        ls -l ${INSTALL_PREFIX}/include/gmp*.h || echo "Warning: GMP headers might not be installed correctly."
        ls -l ${INSTALL_PREFIX}/${LIB_DIR_NAME}/libgmp.* || echo "Warning: GMP library might not be installed correctly."

        # --- Build MPFR ---
        echo "构建 MPFR (版本: ${MPFR_VERSION})..."
        cd mpfr-${MPFR_VERSION}
        # MPFR is built to RUN on the ANDROID machine (host) using a CROSS compiler
        export CC="${TOOLCHAIN_TARGET}-clang"
        export CXX="${TOOLCHAIN_TARGET}-clang++"
        export AR="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar" # Still need build-machine tools
        export RANLIB="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib"
        export STRIP="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
        # PATH should still contain cross binutils

        ./configure --prefix=${INSTALL_PREFIX} --host=${TARGET_TRIPLE} \ # <--- Host is the Android machine
                    --with-gmp=${INSTALL_PREFIX} \
                    --disable-static --enable-shared
        echo "运行 MPFR configure 完成。开始 make..."
        make -j${NPROC} || { echo "MPFR make failed"; exit 1; }
        make install || { echo "MPFR make install failed"; exit 1; }
        echo "MPFR 构建和安装完成。"
        cd ..
        echo "Checking MPFR installation in ${INSTALL_PREFIX}/include and ${INSTALL_PREFIX}/${LIB_DIR_NAME}:"
        ls -l ${INSTALL_PREFIX}/include/mpfr.h || echo "Warning: MPFR header might not be installed correctly."
        ls -l ${INSTALL_PREFIX}/${LIB_DIR_NAME}/libmpfr.* || echo "Warning: MPFR library might not be installed correctly."

        # --- Build MPC ---
        echo "构建 MPC (版本: ${MPC_VERSION})..."
        cd mpc-${MPC_VERSION}
        # MPC is built to RUN on the ANDROID machine (host) using a CROSS compiler
        export CC="${TOOLCHAIN_TARGET}-clang"
        export CXX="${TOOLCHAIN_TARGET}-clang++"
        export AR="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar" # Still need build-machine tools
        export RANLIB="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ranlib"
        export STRIP="${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
        # PATH should still contain cross binutils

        ./configure --prefix=${INSTALL_PREFIX} --host=${TARGET_TRIPLE} \ # <--- Host is the Android machine
                    --with-gmp=${INSTALL_PREFIX} \
                    --with-mpfr=${INSTALL_PREFIX} \
                    --disable-static --enable-shared
        echo "运行 MPC configure 完成。开始 make..."
        make -j${NPROC} || { echo "MPC make failed"; exit 1; }
        make install || { echo "MPC make install failed"; exit 1; }
        echo "MPC 构建和安装完成。"
        cd ..
        echo "Checking MPC installation in ${INSTALL_PREFIX}/include and ${INSTALL_PREFIX}/${LIB_DIR_NAME}:"
        ls -l ${INSTALL_PREFIX}/include/mpc.h || echo "Warning: MPC header might not be installed correctly."
        ls -l ${INSTALL_PREFIX}/${LIB_DIR_NAME}/libmpc.* || echo "Warning: MPC library might not be installed correctly."

        # Add the final install path to PATH for GCC build (it was temporarily set inside the step)
        # Overwrite or append based on desired clarity
        echo "Adding ${INSTALL_PREFIX}/bin to PATH for subsequent steps (again to be sure)"
        echo "PATH=${INSTALL_PREFIX}/bin:${PATH}" >> $GITHUB_ENV
        echo "Adding ${INSTALL_PREFIX}/${LIB_DIR_NAME} to LD_LIBRARY_PATH for subsequent steps"
        echo "LD_LIBRARY_PATH=${INSTALL_PREFIX}/${LIB_DIR_NAME}:${LD_LIBRARY_PATH}" >> $GITHUB_ENV
        echo "依赖项构建步骤完成。"

    - name: 构建 GCC
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        echo "开始构建 GCC (版本: ${GCC_VERSION})..."
        # PATH should now contain the cross Binutils from the previous step
        echo "Current PATH for GCC build: $PATH"
        echo "Current LD_LIBRARY_PATH for GCC build: $LD_LIBRARY_PATH"
        cd gcc-${GCC_VERSION}

        NPROC=$(nproc)
        echo "Using $NPROC parallel jobs for make."

        # GCC is built to RUN on the ANDROID machine (host) and TARGET the ANDROID machine (target)
        # It is CROSS compiled from the BUILD machine.
        # Use the cross Binutils installed in the previous step (should be in PATH)
        # Use the NDK Clang for the first stage compiler
        export CC_FOR_BUILD="${TOOLCHAIN_TARGET}-clang" # Use NDK Clang for initial stages
        export CXX_FOR_BUILD="${TOOLCHAIN_TARGET}-clang++"

        # Tools for the final compiler (these will be the ones built)
        # Make sure they are not picking up system tools accidentally
        export AR_FOR_TARGET="${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ar"
        export RANLIB_FOR_TARGET="${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ranlib"
        export STRIP_FOR_TARGET="${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-strip"
        export NM_FOR_TARGET="${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-nm"
        export AS_FOR_TARGET="${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-as" # Should be found via PATH, but explicit is safer
        export LD_FOR_TARGET="${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ld" # Should be found via PATH, but explicit is safer

        # Set environment variables for the compiler used to *build* GCC itself
        # These should be the NDK Clang
        export CC="${TOOLCHAIN_TARGET}-clang"
        export CXX="${TOOLCHAIN_TARGET}-clang++"

        # LDFLAGS 指向安装的库目录
        export LDFLAGS="-L${INSTALL_PREFIX}/${LIB_DIR_NAME}"
        # CPPFLAGS 指向安装的头文件目录
        export CPPFLAGS="-I${INSTALL_PREFIX}/include"
        # Linker might need explicit sysroot for runtime libs? Add if needed.
        export LDFLAGS_FOR_TARGET="${LDFLAGS} --sysroot=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot" # LDFLAGS for the target
        export CPPFLAGS_FOR_TARGET="${CPPFLAGS} --sysroot=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot" # CPPFLAGS for the target

        echo "Using build compiler: CC_FOR_BUILD=$CC_FOR_BUILD CXX_FOR_BUILD=$CXX_FOR_BUILD"
        echo "Using target tools: AR_FOR_TARGET=$AR_FOR_TARGET etc."
        echo "CPPFLAGS for GCC: $CPPFLAGS"
        echo "LDFLAGS for GCC: $LDFLAGS"
        echo "CPPFLAGS_FOR_TARGET for GCC: $CPPFLAGS_FOR_TARGET"
        echo "LDFLAGS_FOR_TARGET for GCC: $LDFLAGS_FOR_TARGET"

        # Checking tools that will be used by GCC configure/make
        echo "Checking build compiler:"
        "$CC_FOR_BUILD" --version || { echo "CC_FOR_BUILD check failed"; exit 1; }
        echo "Checking target linker:"
        ls -l "$LD_FOR_TARGET"
        "$LD_FOR_TARGET" --version || { echo "LD_FOR_TARGET version check failed"; exit 1; }


        echo "--- Preparing to configure GCC ---"
        echo "PWD=$(pwd)"
        ls -l ./configure
        if [ ! -x ./configure ]; then
           echo "错误: configure脚本不存在或不可执行！"
           exit 1
        fi
        echo "Configure command about to run."

        # Execute configure for GCC: build on build, host on target, target is target
        # Need to point to the Binutils installed in the previous step
        ./configure --target=${TARGET_TRIPLE} --prefix=${INSTALL_PREFIX} \
                    --host=${TARGET_TRIPLE} \ # <--- Host is the Android machine
                    --build=$(./config.guess) \ # <--- Build is the build machine
                    --with-sysroot=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot \
                    --with-gmp=${INSTALL_PREFIX} \
                    --with-mpfr=${INSTALL_PREFIX} \
                    --with-mpc=${INSTALL_PREFIX} \
                    --with-as=${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-as \ # Explicitly point to installed Binutils
                    --with-ld=${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ld \ # Explicitly point to installed Binutils
                    --enable-languages=c,c++ \
                    --disable-nls \
                    --disable-libssp \
                    --disable-libgomp \
                    --disable-libquadmath \
                    --disable-libsanitizer \
                    --disable-libatomic \
                    --disable-gprofng \
                    --disable-bootstrap \
                    --disable-multilib \
                    --disable-static --enable-shared \
                    --enable-initfini-array # Required for some Android versions/setups

        echo "运行 GCC configure 完成。开始 make..."
        # GCC make can take a very long time!
        make -j${NPROC} || { echo "GCC make failed"; exit 1; }
        # Only install the target tools, not the native ones
        make install-strip || { echo "GCC make install failed"; exit 1; } # use install-strip to reduce size

        echo "GCC 构建和安装完成。"
        cd ..
        echo "Checking GCC installation in ${INSTALL_PREFIX}/bin:"
        ls -l ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-gcc || echo "Warning: GCC compiler might not be installed correctly."

    - name: 创建 Magisk 模块结构
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        echo "创建 Magisk 模块结构..."
        MODULE_ID="gcc-cross-android-${TARGET_ARCH}"
        MODULE_NAME="GCC for Android (${TARGET_ARCH})"
        MODULE_VERSION="v${GCC_VERSION}"
        MODULE_AUTHOR="GitHub Actions CI"

        # 创建目录结构
        mkdir -p ${MODULE_DIR}/system/bin
        mkdir -p ${MODULE_DIR}/system/${LIB_DIR_NAME}
        # Need to copy the actual GCC installation path, which includes the target triple
        # The internal structure is usually $prefix/libexec/gcc/$target_triple/$version
        mkdir -p ${MODULE_DIR}/system/libexec/gcc/${TARGET_TRIPLE}/${GCC_VERSION}
        mkdir -p ${MODULE_DIR}/META-INF/com/google/android

        echo "复制已安装的文件到模块目录..."
        copy_or_fail() {
            echo "Copying: $1 -> $2"
            cp -fv "$1" "$2" || { echo "错误: 无法复制 '$1' 到 '$2'. 安装步骤可能失败。"; exit 1; }
        }
        copy_dir_or_fail() {
            echo "Copying directory: $1 -> $2"
            cp -rfv "$1" "$2" || { echo "错误: 无法复制目录 '$1' 到 '$2'. 安装步骤可能失败。"; exit 1; }
        }

        # Copy main executables - These are in ${INSTALL_PREFIX}/bin
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-gcc ${MODULE_DIR}/system/bin/gcc
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-g++ ${MODULE_DIR}/system/bin/g++
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-cpp ${MODULE_DIR}/system/bin/cpp
        # Copy Binutils tools - These are also in ${INSTALL_PREFIX}/bin from the Binutils install step
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-as ${MODULE_DIR}/system/bin/as
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ld ${MODULE_DIR}/system/bin/ld
        # Add other binutils if needed (ar, ranlib, strip, objdump etc.)
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ar ${MODULE_DIR}/system/bin/ar
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ranlib ${MODULE_DIR}/system/bin/ranlib
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-strip ${MODULE_DIR}/system/bin/strip
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-nm ${MODULE_DIR}/system/bin/nm
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-objdump ${MODULE_DIR}/system/bin/objdump
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-readelf ${MODULE_DIR}/system/bin/readelf
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-size ${MODULE_DIR}/system/bin/size
        copy_or_fail ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-strings ${MODULE_DIR}/system/bin/strings

        # Copy GCC internal tools (critical) - These are in ${INSTALL_PREFIX}/libexec/gcc/...
        copy_dir_or_fail ${INSTALL_PREFIX}/libexec/gcc/${TARGET_TRIPLE}/${GCC_VERSION}/. ${MODULE_DIR}/system/libexec/gcc/${TARGET_TRIPLE}/${GCC_VERSION}/

        # Copy dynamic libraries (essential for dynamic linking)
        # Use find to handle version suffixes gracefully
        find ${INSTALL_PREFIX}/${LIB_DIR_NAME}/ -maxdepth 1 -name 'libstdc++.so*' -exec cp -fv {} ${MODULE_DIR}/system/${LIB_DIR_NAME}/ \;
        find ${INSTALL_PREFIX}/${LIB_DIR_NAME}/ -maxdepth 1 -name 'libgcc_s.so*' -exec cp -fv {} ${MODULE_DIR}/system/${LIB_DIR_NAME}/ \;
        find ${INSTALL_PREFIX}/${LIB_DIR_NAME}/ -maxdepth 1 -name 'libgmp.so*' -exec cp -fv {} ${MODULE_DIR}/system/${LIB_DIR_NAME}/ \;
        find ${INSTALL_PREFIX}/${LIB_DIR_NAME}/ -maxdepth 1 -name 'libmpfr.so*' -exec cp -fv {} ${MODULE_DIR}/system/${LIB_DIR_NAME}/ \;
        find ${INSTALL_PREFIX}/${LIB_DIR_NAME}/ -maxdepth 1 -name 'libmpc.so*' -exec cp -fv {} ${MODULE_DIR}/system/${LIB_DIR_NAME}/ \;

        # Verify libs were copied
        if [ -z "$(ls -A ${MODULE_DIR}/system/${LIB_DIR_NAME})" ]; then
           echo "错误: 未能复制任何共享库到 ${MODULE_DIR}/system/${LIB_DIR_NAME}"
           exit 1
        fi

        # Create module.prop file
        echo "创建 module.prop..."
        echo "id=${MODULE_ID}" > ${MODULE_DIR}/module.prop
        echo "name=${MODULE_NAME}" >> ${MODULE_DIR}/module.prop
        echo "version=${MODULE_VERSION}" >> ${MODULE_DIR}/module.prop
        safe_version_code=$(echo $GCC_VERSION | tr -d '.' | cut -c -4)0
        echo "versionCode=${safe_version_code}" >> ${MODULE_DIR}/module.prop
        echo "author=${MODULE_AUTHOR}" >> ${MODULE_DIR}/module.prop
        echo "description=为 Android ${TARGET_ARCH} 交叉编译的 GCC ${GCC_VERSION} 工具链。" >> ${MODULE_DIR}/module.prop
        echo "arch=${TARGET_ARCH}" >> ${MODULE_DIR}/module.prop

        # Create META-INF files
        echo "创建 META-INF 文件..."
        echo '#!/sbin/sh' > ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo '# Simple Magisk installer script stub' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'ui_print("- 安装 ${MODULE_NAME}")' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'ui_print("- 版本: ${MODULE_VERSION}")' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'ui_print("- 架构: ${TARGET_ARCH}")' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'ui_print(" ")' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo '# Magisk handles file extraction based on the zip structure' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'ui_print("- 文件将被安装到 /system")' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'exit 0' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        chmod 755 ${MODULE_DIR}/META-INF/com/google/android/update-binary
        touch ${MODULE_DIR}/META-INF/com/google/android/updater-script # Typically empty
        echo "模块结构创建完成。"
        echo "模块内容概览:"
        ls -R ${MODULE_DIR}

    - name: 打包模块为 Zip 文件
      run: |
        #!/bin/bash
        set -e # Ensure script exits on error

        echo "开始打包 Zip 文件..."
        cd ${MODULE_DIR}
        zip -r9 ${GITHUB_WORKSPACE}/gcc-magisk-module-${TARGET_ARCH}.zip .
        cd ${GITHUB_WORKSPACE}
        echo "Zip 文件打包完成: gcc-magisk-module-${TARGET_ARCH}.zip"
        ls -l gcc-magisk-module-${TARGET_ARCH}.zip

    - name: 上传构建产物
      uses: actions/upload-artifact@v4
      with:
        name: gcc-magisk-module-${{ env.TARGET_ARCH }}
        path: ${{ github.workspace }}/gcc-magisk-module-${{ env.TARGET_ARCH }}.zip
        if-no-files-found: error # 如果 zip 文件没找到则报错