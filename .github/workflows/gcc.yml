name: 构建 GCC Magisk 模块

on:
  push:
    branches: [ main ] # 或者你的开发分支
  workflow_dispatch: # 允许手动触发

jobs:
  build:
    runs-on: ubuntu-latest # 必须使用 Linux 运行环境

    steps:
    - name: 检出代码 (如果你的仓库包含辅助脚本/配置)
      uses: actions/checkout@v3

    - name: 安装基础依赖
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential wget unzip bc tar xz-utils # 确保解压 .tar.xz 需要的工具存在

    - name: 设置 Android NDK
      id: setup-ndk
      run: |
        NDK_VERSION="android-ndk-r25c" # 示例 NDK 版本
        echo "正在下载 NDK $NDK_VERSION..."
        wget -q https://dl.google.com/android/repository/${NDK_VERSION}-linux.zip
        unzip -q ${NDK_VERSION}-linux.zip
        # 将 NDK 路径添加到环境变量，供后续步骤使用
        echo "ANDROID_NDK_HOME=${GITHUB_WORKSPACE}/${NDK_VERSION}" >> $GITHUB_ENV
        echo "NDK 路径: ${GITHUB_WORKSPACE}/${NDK_VERSION}"

    - name: 定义构建变量
      id: build-vars
      run: |
        # 目标架构 (例如 arm64)
        TARGET_ARCH="aarch64"
        # Android API Level (必须是 NDK 支持的, 例如 21 对应 Android 5.0+)
        API_LEVEL="21"
        # 对应的 Android Target Triple
        TARGET_TRIPLE="${TARGET_ARCH}-linux-android"
        # 包含 API Level 的完整工具链目标 (NDK Clang 使用这个)
        TOOLCHAIN_TARGET="${TARGET_TRIPLE}${API_LEVEL}"
        # 临时安装目录的前缀
        INSTALL_PREFIX="${GITHUB_WORKSPACE}/install_dir"
        # Magisk 模块目录
        MODULE_DIR="${GITHUB_WORKSPACE}/gcc_magisk_module"

        echo "TARGET_TRIPLE=${TARGET_TRIPLE}" >> $GITHUB_ENV
        echo "TOOLCHAIN_TARGET=${TOOLCHAIN_TARGET}" >> $GITHUB_ENV
        echo "INSTALL_PREFIX=${INSTALL_PREFIX}" >> $GITHUB_ENV
        echo "MODULE_DIR=${MODULE_DIR}" >> $GITHUB_ENV
        # 将 NDK 工具链添加到 PATH 环境变量
        echo "PATH=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/bin:${PATH}" >> $GITHUB_ENV

        mkdir -p $INSTALL_PREFIX
        mkdir -p $MODULE_DIR

    - name: 下载源代码 (GCC, Binutils, GMP, MPFR, MPC)
      run: |
        # 定义稳定版本 (示例)
        GCC_VERSION="12.2.0"
        BINUTILS_VERSION="2.39"
        GMP_VERSION="6.2.1"
        MPFR_VERSION="4.1.0"
        MPC_VERSION="1.2.1"

        echo "正在下载源码..."
        wget -q https://ftp.gnu.org/gnu/gcc/gcc-${GCC_VERSION}/gcc-${GCC_VERSION}.tar.gz
        wget -q https://ftp.gnu.org/gnu/binutils/binutils-${BINUTILS_VERSION}.tar.gz
        wget -q https://ftp.gnu.org/gnu/gmp/gmp-${GMP_VERSION}.tar.xz
        wget -q https://ftp.gnu.org/gnu/mpfr/mpfr-${MPFR_VERSION}.tar.xz
        wget -q https://ftp.gnu.org/gnu/mpc/mpc-${MPC_VERSION}.tar.gz
        echo "下载完成，正在解压..."
        tar -xf gcc-${GCC_VERSION}.tar.gz
        tar -xf binutils-${BINUTILS_VERSION}.tar.gz
        tar -xf gmp-${GMP_VERSION}.tar.xz
        tar -xf mpfr-${MPFR_VERSION}.tar.xz
        tar -xf mpc-${MPC_VERSION}.tar.gz
        echo "解压完成。"

    - name: 构建依赖项 (Binutils, GMP, MPFR, MPC)
      # 注意：这里的 configure 只是示例，极有可能需要修改！
      # 关键：需要添加 --host=${TARGET_TRIPLE} 用于交叉编译！
      run: |
        echo "开始构建依赖项..."
        # --- 构建 Binutils ---
        echo "构建 Binutils..."
        cd binutils-${BINUTILS_VERSION}
        # !! 重要: 下面的 configure 需要仔细检查并添加 --host=${TARGET_TRIPLE} !!
        CC=${TOOLCHAIN_TARGET}-clang CXX=${TOOLCHAIN_TARGET}-clang++ AR=${TARGET_TRIPLE}-ar RANLIB=${TARGET_TRIPLE}-ranlib STRIP=${TARGET_TRIPLE}-strip \
        ./configure --target=${TARGET_TRIPLE} --prefix=${INSTALL_PREFIX} \
                    --host=${TARGET_TRIPLE} \ # <-- 添加了 host (需要验证)
                    --with-sysroot=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot \
                    --disable-nls --disable-werror
        echo "运行 Binutils make..."
        # make -j$(nproc) # 取消注释以实际编译
        # make install # 取消注释以实际安装
        echo "跳过 Binutils make & make install (占位符)" # 编译耗时，暂时跳过
        cd ..

        # --- 构建 GMP ---
        echo "构建 GMP..."
        cd gmp-${GMP_VERSION}
        # !! 重要: 需要完成 configure, 包含 --host=${TARGET_TRIPLE} !!
        # ./configure --prefix=${INSTALL_PREFIX} --host=${TARGET_TRIPLE} CC=${TOOLCHAIN_TARGET}-clang CXX=${TOOLCHAIN_TARGET}-clang++ AR=${TARGET_TRIPLE}-ar RANLIB=${TARGET_TRIPLE}-ranlib --enable-cxx --disable-static --enable-shared # 示例配置
        echo "跳过 GMP configure & make (占位符)"
        # make -j$(nproc) # 取消注释以实际编译
        # make install # 取消注释以实际安装
        cd ..

        # --- 构建 MPFR ---
        echo "构建 MPFR..."
        cd mpfr-${MPFR_VERSION}
        # !! 重要: 需要完成 configure, 包含 --host, --with-gmp !!
        # ./configure --prefix=${INSTALL_PREFIX} --host=${TARGET_TRIPLE} --with-gmp=${INSTALL_PREFIX} CC=${TOOLCHAIN_TARGET}-clang CXX=${TOOLCHAIN_TARGET}-clang++ AR=${TARGET_TRIPLE}-ar RANLIB=${TARGET_TRIPLE}-ranlib --disable-static --enable-shared # 示例配置
        echo "跳过 MPFR configure & make (占位符)"
        # make -j$(nproc) # 取消注释以实际编译
        # make install # 取消注释以实际安装
        cd ..

        # --- 构建 MPC ---
        echo "构建 MPC..."
        cd mpc-${MPC_VERSION}
        # !! 重要: 需要完成 configure, 包含 --host, --with-gmp, --with-mpfr !!
        # ./configure --prefix=${INSTALL_PREFIX} --host=${TARGET_TRIPLE} --with-gmp=${INSTALL_PREFIX} --with-mpfr=${INSTALL_PREFIX} CC=${TOOLCHAIN_TARGET}-clang CXX=${TOOLCHAIN_TARGET}-clang++ AR=${TARGET_TRIPLE}-ar RANLIB=${TARGET_TRIPLE}-ranlib --disable-static --enable-shared # 示例配置
        echo "跳过 MPC configure & make (占位符)"
        # make -j$(nproc) # 取消注释以实际编译
        # make install # 取消注释以实际安装
        cd ..

        # 确保编译好的依赖项在 PATH 中，以便 GCC 构建时能找到
        echo "PATH=${INSTALL_PREFIX}/bin:${PATH}" >> $GITHUB_ENV
        echo "依赖项构建步骤完成 (大部分跳过)。"

    - name: 构建 GCC
      # 这是最复杂的部分。需要非常仔细的 configure 参数。
      # 静态链接非常难，建议先尝试动态链接。
      run: |
        echo "开始构建 GCC..."
        cd gcc-${GCC_VERSION}
        # !! 非常重要: 下面的 configure 只是骨架，需要大量调试和添加选项 !!
        # !! 特别是 --host, --target, --build 的正确使用 !!
        # !! 强烈建议先移除 --enable-static, --disable-shared，尝试动态链接 !!
        CC=${TOOLCHAIN_TARGET}-clang CXX=${TOOLCHAIN_TARGET}-clang++ AR=${TARGET_TRIPLE}-ar RANLIB=${TARGET_TRIPLE}-ranlib STRIP=${TARGET_TRIPLE}-strip \
        ./configure --target=${TARGET_TRIPLE} --prefix=${INSTALL_PREFIX} \
                    --host=${TARGET_TRIPLE} \ # <-- 添加了 host (需要验证GCC的用法)
                    --with-sysroot=${ANDROID_NDK_HOME}/toolchains/llvm/prebuilt/linux-x86_64/sysroot \
                    --with-gmp=${INSTALL_PREFIX} \
                    --with-mpfr=${INSTALL_PREFIX} \
                    --with-mpc=${INSTALL_PREFIX} \
                    --with-binutils=${INSTALL_PREFIX}/bin \
                    --enable-languages=c,c++ \
                    --disable-nls \
                    --disable-libssp \
                    --disable-libgomp \
                    --disable-libquadmath \
                    --enable-static \ # <-- 尝试静态链接 (非常困难)
                    # --disable-shared # <-- 配合静态链接
                    # 其他可能的选项: --disable-bootstrap, --disable-multilib 等等
        echo "运行 GCC make..."
        # make -j$(nproc) # 非常非常耗时，可能数小时
        # make install
        echo "跳过 GCC make & make install (占位符)" # 编译耗时，暂时跳过
        cd ..
        echo "GCC 构建步骤完成 (跳过)。"

    - name: 创建 Magisk 模块结构
      run: |
        echo "创建 Magisk 模块结构..."
        MODULE_ID="gcc-cross-android"
        MODULE_NAME="GCC for Android (交叉编译)"
        MODULE_VERSION="v${GCC_VERSION}" # 示例版本号
        MODULE_AUTHOR="你的名字"

        # 创建目录结构
        mkdir -p ${MODULE_DIR}/system/bin
        mkdir -p ${MODULE_DIR}/system/lib64 # 如果需要32位则调整为 lib
        mkdir -p ${MODULE_DIR}/system/libexec/gcc/${TARGET_TRIPLE}/${GCC_VERSION} # GCC 内部可执行文件路径
        mkdir -p ${MODULE_DIR}/META-INF/com/google/android

        # !! 注意: 下面的 cp 命令依赖于前面的构建步骤成功 !!
        # !! 由于构建被跳过，这里会失败或复制不存在的文件 !!
        # !! 这里仅作为最终目标结构的示例 !!
        echo "复制文件 (占位符)..."
        # cp ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-gcc ${MODULE_DIR}/system/bin/gcc || echo "警告: ${TARGET_TRIPLE}-gcc 未找到"
        # cp ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-g++ ${MODULE_DIR}/system/bin/g++ || echo "警告: ${TARGET_TRIPLE}-g++ 未找到"
        # cp ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-cpp ${MODULE_DIR}/system/bin/cpp || echo "警告: ${TARGET_TRIPLE}-cpp 未找到"
        # cp ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-as ${MODULE_DIR}/system/bin/as || echo "警告: ${TARGET_TRIPLE}-as 未找到"
        # cp ${INSTALL_PREFIX}/bin/${TARGET_TRIPLE}-ld ${MODULE_DIR}/system/bin/ld || echo "警告: ${TARGET_TRIPLE}-ld 未找到"
        # cp -r ${INSTALL_PREFIX}/libexec/gcc/${TARGET_TRIPLE}/${GCC_VERSION}/* ${MODULE_DIR}/system/libexec/gcc/${TARGET_TRIPLE}/${GCC_VERSION}/ || echo "警告: GCC libexec 文件未找到"
        # 如果是动态链接，需要复制 .so 文件到 system/lib64:
        # cp ${INSTALL_PREFIX}/lib64/libstdc++.so* ${MODULE_DIR}/system/lib64/ || echo "警告: libstdc++.so 未找到"
        # cp ${INSTALL_PREFIX}/lib64/libgcc_s.so* ${MODULE_DIR}/system/lib64/ || echo "警告: libgcc_s.so 未找到"
        # cp ${INSTALL_PREFIX}/lib64/libgmp.so* ${MODULE_DIR}/system/lib64/ || echo "警告: libgmp.so 未找到"
        # cp ${INSTALL_PREFIX}/lib64/libmpfr.so* ${MODULE_DIR}/system/lib64/ || echo "警告: libmpfr.so 未找到"
        # cp ${INSTALL_PREFIX}/lib64/libmpc.so* ${MODULE_DIR}/system/lib64/ || echo "警告: libmpc.so 未找到"

        # 创建 module.prop 文件
        echo "创建 module.prop..."
        echo "id=${MODULE_ID}" > ${MODULE_DIR}/module.prop
        echo "name=${MODULE_NAME}" >> ${MODULE_DIR}/module.prop
        echo "version=${MODULE_VERSION}" >> ${MODULE_DIR}/module.prop
        echo "versionCode=$(echo $GCC_VERSION | tr -d . )0" >> ${MODULE_DIR}/module.prop # 简单的版本代码
        echo "author=${MODULE_AUTHOR}" >> ${MODULE_DIR}/module.prop
        echo "description=为 Android ${TARGET_ARCH} 交叉编译的 GCC ${GCC_VERSION} (构建未完成)" >> ${MODULE_DIR}/module.prop

        # 创建空的 update-binary 和 updater-script
        echo "创建 META-INF 文件..."
        echo '#!/sbin/sh' > ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo '# 安装脚本 (占位符)' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'ui_print("正在安装 ${MODULE_NAME} (占位符)")' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'ui_print("注意: 这是一个占位符模块，实际构建未完成。")' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        echo 'exit 0' >> ${MODULE_DIR}/META-INF/com/google/android/update-binary
        chmod 755 ${MODULE_DIR}/META-INF/com/google/android/update-binary
        touch ${MODULE_DIR}/META-INF/com/google/android/updater-script # 简单模块通常为空
        echo "模块结构创建完成。"

    - name: 打包模块为 Zip 文件
      run: |
        echo "开始打包 Zip 文件..."
        cd ${MODULE_DIR}
        zip -r9 ${GITHUB_WORKSPACE}/gcc-magisk-module-${TARGET_ARCH}.zip .
        cd ${GITHUB_WORKSPACE}
        echo "Zip 文件打包完成: gcc-magisk-module-${TARGET_ARCH}.zip"

    - name: 上传构建产物
      uses: actions/upload-artifact@v4 # <--- 这里已更新到 v4
      with:
        name: gcc-magisk-module-${{ env.TARGET_ARCH }} # 构建产物名称
        path: ${{ github.workspace }}/gcc-magisk-module-${{ env.TARGET_ARCH }}.zip # 要上传的文件路径